/*
 * Copyright(c) 2015 Cisco Systems, Inc. and others.  All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this distribution,
 * and is available at http://www.eclipse.org/legal/epl-v10.html
 *
 */
module onem2m {
    yang-version 1;
    namespace "urn:opendaylight:params:xml:ns:yang:iotdm:onem2m";
    prefix "onem2m";

    revision "2015-01-05" {
        description "Initial revision of the IoTDM onem2m resource model";
    }

    /*
    * This is the onenm2m model, we support more than one cseBase per system; this gives more flexibility.
    * Of course, for a small gateway, you'll probably only want to have one; this may be true for large IN-CSE's too.
    * The resource tree is a tree of resources much like the directory structure in a unix filesystem.  Resources
    * can be CRUDed using a hierarchical resource designation.  When a resource is created, a system wide unique
    * resource-id is allocated.  This is the KEY in all inter-resource interactions.  Resources can be accessed using
    * a hierarchical URI, or using the resource-id method, ie the non-hierarchical access mode.
    * Example: hostname://cseBaseName1/123456 is a valid URI, where 123456 is a resource-id that was assigned by
    * the system and returned to the user.  Think of it like a tinyUrl and its likely purpose is to keep msgs small for
    * constrained devices wishing to access the system.  As further explanation: assume the tree has a hierarchy of
    * resources and the user creates this resource under hostname://cseBaseName/A/B/C/D/E/F, called Z, this returns
    * 123456 as its resource-id. A retrieve can per performed on this resource using a) hostname://cseBaseName/123456
    * or b) using hostname://cseBaseName/A/B/D/E/F/G/Z.
    *
    * Each resource has a set of attributes that are stored with it. The names and values of these attributes are filled
    * in by the code in onem2m-core.  See the RPC request below.  I chose initially to be quite generic with the
    * attributes to keep the model flexible and not specific as the specs are still in flux.  Once they become more
    * hardened, it might be useful to create specific instances of each resource type and hang them off the resource
    * tree, and also add in specific fields into the resource that are common and not likely to change.  Also, I might
    * use a better/quicker method to access the data store that is binding independent. But for now, the data store
    * uses the binding-aware data store based on this model.
    */
    container onem2m-cse-list {
        config false;
        list onem2m-cse {
            key name;
            leaf name {
                type string;
            }
            leaf resource-id {
                type string;
            }
        }
    }
    container onem2m-resource-tree {
        config false;
        list onem2m-resource {

            /* tree structure attributes */
            key resource-id;
            leaf resource-id {
                type string;
            }
            leaf parent-id {
                type string;
            }
            leaf name { // the onem2m resource name
                type string;
            }
            leaf oldest-id {
                type string;
            }
            leaf latest-id {
                type string;
            }
            list child {
                key name;
                leaf name {
                    type string;
                }
                leaf resource-id {
                    type string;
                }
                leaf prev-id {
                    type string;
                }
                leaf next-id {
                    type string;
                }
            }

            /* resource specific attributes */
            list attr {
                key name;
                leaf name {
                    type string;
                }
                leaf value {
                    type string;
                }
            }
            list attr-set {
                key name;
                leaf name {
                    type string;
                }
                list member {
                    key member;
                    leaf member {
                        type string;
                    }
                }
            }
        }
    }

    /*
    * The following primitive grouping and rpc are for the CRUD/N operations on the one m2m resource tree.  See
    * onem2m-core/.../rest/RequestPrimitive.java and .../rest/ResponsePrimitive.java for the list of name/value pairs
    * that are possible/required for each onenm2m operation.  The semantics of what resource type can be created and
    * where are enforced by the code.  The resource tree is a meta model where each resource will contain a list
    * of resource specific attrs.  These attrs are ultimately placed in the datastore through the Onem2mService RPC
    * interface.  The RPC calls are invoked by either RESTconf, the standard onem2m-protocols (CoAP, MQTT, HTTP), or
    * local applications (see onem2m-apps/local).  These primitives are baseon on the CDT-requestPrimitive.xsd file
    * provided by onem2m.org.
    */
    grouping onem2m-primitive-list {
        list onem2m-primitive {
            leaf name {
                type string;
            }
            leaf value {
                type string;
            }
        }
    }

    rpc onem2m-request-primitive {
        description
          "Perform an onem2m operation on this resource";

        input {
            uses onem2m-primitive-list;
        }
        output {
            uses onem2m-primitive-list;
        }
    }

    /*
    * The system must be provisioned before using it.  A cse name, type must be given, then the system can be moved
    * to a provisioned state.
    */
    rpc onem2m-cse-provisioning {
        description
          "Provision the onem2m cse base for the system";

        input {
            uses onem2m-primitive-list;
        }
        output {
            uses onem2m-primitive-list;
        }
    }

    /*
    * Convenient way to reset the data store to EMPTY
    */
    rpc onem2m-cleanup-store {
        description
          "Delete the onem2m datastore";
    }

    /*
    * Debug method to dump the resource tree to the karaf log. It is dumped in two ways, 1) a list of all the
    * resources in the system (no specific order), 2) dumped hierarchically from the cse root.  An optional
    * resourceId can be provided indicating which resourceId to start dumping from.
    */
    rpc onem2m-dump-resource-tree {
        description "Dump the onem2m data store to the karaf log";

        input {
            leaf dump-method {
                mandatory true;
                type enumeration {
                    enum "RAW" {
                        value 1;
                        description
                          "Raw dump of cse-list and resource tree";
                    }
                    enum "HIERARCHICAL" {
                        value 2;
                        description
                          "Enable logging";
                    }
                }
                description
                    "Type of the test to benchmark";
            }
            leaf resourceUri {
                type string;
                default "";
                description
                  "If RAW, dump only this resource, if HIERARCHICAL, dump from this root, empty for ALL";
              }
        }
    }
}
